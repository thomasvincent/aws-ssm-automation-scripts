name: PR - Validate new/changed SSM YAML documents

on:
  pull_request:
    branches: [ main ]

permissions:
  contents: read

jobs:
  validate-changed:
    name: Validate changed YAML only
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Detect changed YAML files
        id: diff
        run: |
          set -euo pipefail
          base_sha="${{ github.event.pull_request.base.sha }}"
          head_sha="${{ github.event.pull_request.head.sha }}"
          files=$(git diff --name-only "$base_sha" "$head_sha" | grep -E '\.(ya?ml)$' || true)
          echo "Changed YAML files:"
          echo "$files"
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$files" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          if [ -z "$files" ]; then echo "none=true" >> $GITHUB_OUTPUT; fi

      - name: Determine SSM Automation docs and enforce naming
        id: find-ssm
        if: steps.diff.outputs.none != 'true'
        run: |
          set -euo pipefail
          ssm_files=""
          n_errors=0
          # SSM docs policy: top-level *.yaml, snake_case: ^[a-z0-9_]+\.yaml$
          for f in ${{ steps.diff.outputs.files }}; do
            # Consider only top-level YAML
            if [[ "$f" =~ ^[^/]+\.ya?ml$ ]]; then
              # naming check only for .yaml files in repo root
              if [[ "$f" =~ \.yaml$ ]]; then
                base=$(basename "$f")
                if [[ ! "$base" =~ ^[a-z0-9_]+\.yaml$ ]]; then
                  echo "Naming violation: $f (must match ^[a-z0-9_]+\.yaml$)"
                  n_errors=$((n_errors+1))
                fi
              fi
              # detect SSM Automation doc by presence of schemaVersion and assumeRole keys
              if grep -q "schemaVersion" "$f" && grep -q "assumeRole:" "$f"; then
                ssm_files+="$f\n"
              fi
            fi
          done
          echo "SSM candidate files:"
          echo -e "$ssm_files"
          echo "ssm_files<<EOF" >> $GITHUB_OUTPUT
          echo -e "$ssm_files" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "n_errors=$n_errors" >> $GITHUB_OUTPUT

      - name: Fail on naming convention violations
        if: steps.find-ssm.outputs.n_errors != '0'
        run: |
          echo "SSM document naming violations found. Ensure files are top-level and match ^[a-z0-9_]+\.yaml$."
          exit 1

      - name: Setup Python
        if: steps.diff.outputs.none != 'true'
        uses: actions/setup-python@v6
        with:
          python-version: '3.10'

      - name: Install tools
        if: steps.diff.outputs.none != 'true'
        run: |
          pip install --disable-pip-version-check yamllint pyyaml awscli jsonschema

      - name: Lint YAML
        if: steps.diff.outputs.none != 'true'
        run: |
          echo "Linting changed YAML files"
          echo "${{ steps.diff.outputs.files }}" | xargs -I{} yamllint -c .github/yamllint-config.yml {}

      - name: Basic YAML parse
        if: steps.diff.outputs.none != 'true'
        run: |
          set -euo pipefail
          for f in ${{ steps.diff.outputs.files }}; do
            echo "Validating YAML syntax for $f"
            python - "$f" << 'PY'
import yaml,sys

class CFNLoader(yaml.SafeLoader):
    pass

CFNLoader.add_multi_constructor('!', lambda loader, suffix, node: None)

path=sys.argv[1]
with open(path,'r') as fh:
    yaml.load(fh, Loader=CFNLoader)
print(f"OK: {path}")
PY
          done

      - name: Policy checks for SSM Automation docs
        if: steps.diff.outputs.none != 'true'
        env:
          SSM_FILES: ${{ steps.find-ssm.outputs.ssm_files }}
        run: |
          python - << 'PY'
import os, sys, yaml

class CFNLoader(yaml.SafeLoader):
    pass

CFNLoader.add_multi_constructor('!', lambda loader, suffix, node: None)

files = (os.environ.get('SSM_FILES') or '').strip().splitlines()
errors = []
for f in files:
    if not f:
        continue
    with open(f, 'r') as fh:
        doc = yaml.load(fh, Loader=CFNLoader)
    sv = str(doc.get('schemaVersion', '')).strip()
    ar = doc.get('assumeRole')
    if sv != '0.3':
        errors.append(f"{f}: schemaVersion must be '0.3' (found '{sv}')")
    if not ar:
        errors.append(f"{f}: 'assumeRole' is required at top level")
if errors:
    print("\n".join(errors))
    sys.exit(1)
print("Policy checks passed for SSM docs:\n" + "\n".join(files))
PY

      - name: Configure AWS credentials (optional)
        id: aws-creds
        if: steps.diff.outputs.none != 'true'
        continue-on-error: true
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: JSON schema validation (Automation docs only)
        if: steps.diff.outputs.none != 'true'
        run: |
          set -euo pipefail
          files="${{ steps.find-ssm.outputs.ssm_files }}"
          if [ -z "$files" ]; then
            echo "No SSM Automation docs changed. Skipping schema validation."
            exit 0
          fi
          python scripts/validate_ssm_schema.py $files

      - name: Validate with AWS SSM API (Automation docs only)
        if: steps.diff.outputs.none != 'true' && steps.aws-creds.outcome == 'success'
        run: |
          set -euo pipefail
          files="${{ steps.find-ssm.outputs.ssm_files }}"
          if [ -z "$files" ]; then
            echo "No SSM Automation docs changed. Skipping SSM API validation."
            exit 0
          fi
          python - << 'PY'
import os, subprocess, shlex
files = os.environ.get('FILES','')
PY
          echo "$files" | while read -r f; do
            [ -z "$f" ] && continue
            echo "Validating $f with SSM API"
            aws ssm validate-document --document-type Automation --content file://$f
          done
